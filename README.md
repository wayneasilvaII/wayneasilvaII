# Wayne A. Silva II — Computer Science ePortfolio

## Professional Self-Assessment

  Completing the Computer Science program at Southern New Hampshire University and developing this ePortfolio has allowed me to reflect on my growth from learning foundational programming concepts to designing, analyzing, and enhancing complete software systems. The capstone experience required me to revisit earlier work, evaluate it critically, and improve it using industry relevant tools, modern programming languages, and sound computer science principles. As a result, this portfolio represents both my technical abilities and my approach to professional problem solving.
  
  Throughout the program, I developed strong skills in software design, data structures, and algorithmic thinking. I learned to select appropriate data structures, analyze trade-offs in efficiency and maintainability, and apply these decisions in real implementations. My coursework emphasized writing clear, modular code and improving existing systems rather than simply producing new ones. These skills are reflected in the enhanced artifacts that follow, which demonstrate structured refactoring, performance improvements, and thoughtful system design.
  
  Equally important, the program strengthened my ability to communicate technical ideas clearly and work within collaborative and stakeholder-driven environments. Courses in systems analysis and design as well as software engineering reinforced the importance of requirements gathering, documentation, and adapting technical solutions to real-world constraints. I approach development with the mindset that code must be understandable, maintainable, and defensible,not just functional.
My experience also fostered a strong security and reliability mindset. Through working in multiple languages, including C++ and Rust, and integrating database-backed persistence, I gained a deeper appreciation for memory safety, error handling, and secure data management. I now prioritize correctness, predictability, and long-term stability in software design decisions.

  The artifacts in this ePortfolio work together to illustrate my progression as a computer scientist and software engineer. Each demonstrates a different aspect of my skill set, while collectively they highlight my ability to design, evaluate, and improve software systems. This portfolio serves as both a summary of my academic journey and a foundation for my continued growth as a developer entering the field of computer science.

## Portfolio Overview

This ePortfolio centers on a single software artifact that I selected and incrementally enhanced throughout my capstone experience. The project began as a C++ grocery inventory tracking application and was systematically reviewed, refactored, and extended to demonstrate growth across multiple areas of computer science.

The artifact was enhanced in three key stages:

Software Design and Engineering – The original C++ codebase was analyzed and ported to Rust, emphasizing clearer structure, safer memory management, and improved maintainability.

Algorithms and Data Structures – Core logic was refined through the selection and implementation of more appropriate data structures, improving efficiency, correctness, and overall program clarity.

Database Functionality – Persistent storage was added using a lightweight database, extending the application beyond file-based processing and demonstrating foundational database integration skills.

Together, these enhancements illustrate my ability to evaluate existing systems, make informed design decisions, and iteratively improve software using sound computer science principles. The portfolio reflects both my technical development and my approach to thoughtful, incremental problem solving.

## Artifact Narrative

The corner-store inventory tracker was originally created early in my Computer Science degree program as a learning exercise in C++, object-oriented programming, and fundamental programming concepts. A deliberate focus of the original assignment was manual memory management using pointers, which required careful reasoning about allocation and deallocation. Additionally, the project intentionally avoided using higher-level data structures such as maps, pushing students to implement procedural logic for searching, counting, and sorting data manually. The core logic was concentrated in the retrieveInventory function, which read a text file of grocery items, counted their occurrences, and wrote item frequency pairs to a .dat file. While the program functioned correctly, the implementation was written quickly, lacked documentation, and relied on fragile logic that was difficult to reason about or extend.

For my first enhancement, I selected this artifact because it clearly represented my early programming skill level while offering significant room for improvement. I began by porting the entire codebase from C++ to Rust. This enhancement focused on software design and engineering principles, including code clarity, memory safety, and maintainability. Revisiting my original logic after several years was challenging, particularly because the code was not well-documented, modular, lacked commenting in some areas, and relied on patterns I no longer consider best practice. Porting the program required me to study Rust syntax, ownership rules, and idiomatic patterns, which significantly strengthened my ability to evaluate and implement language appropriate solutions. By eliminating raw pointers and manual memory management, I produced a safer and more readable implementation while preserving the original program’s functionality.

The second enhancement focused on algorithms and data structures. In the original C++ implementation, I used a set and manual searching to count item frequencies, resulting in inefficient and cumbersome logic. Upon reflection, this was a poor fit for the problem domain, which naturally requires key-value pair counting. I redesigned the core frequency counting algorithm using Rust’s BTreeMap<String, i32>. This change replaced multiple lines of manual searching and sorting logic with Rust’s entry() API, allowing item counts to be updated efficiently in logarithmic time. This redesign demonstrates a deeper understanding of algorithmic principles, appropriate data structure selection, and performance trade-offs. It also improved program safety and correctness by leveraging Rust’s guarantees and eliminating entire classes of logical and security flaws present in the original design.

The third enhancement extended the application by adding database functionality. Previously, inventory data was written to a flat .dat file, which provided no structured querying capabilities or reliable persistence. In this enhancement, I integrated a lightweight SQLite database using the rusqlite crate. Inventory data is now stored in an ACID compliant .db file that persists across program executions and can be queried using standard SQL. This enhancement demonstrates my ability to integrate external libraries, design persistent storage solutions, and extend a console application with industry standard database functionality. It also establishes a foundation for future improvements, such as full CRUD operations or a graphical user interface.

Together, these three enhancements transform the original project from a simple instructional assignment into a structured, extensible system that reflects my growth as a computer scientist. Through this process, I strengthened my skills in software design, algorithmic thinking, data structure selection, and database integration. Most importantly, I learned the value of revisiting earlier work with a critical eye, applying modern tools and principles, and making deliberate design choices based on the problem being solved. This artifact now serves as a clear representation of my technical progression throughout the Computer Science program and my readiness to design, evaluate, and enhance real-world software systems.


